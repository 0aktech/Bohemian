---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by brode.
--- DateTime: 07.02.2022 17:37
---

local _, E = ...
local LibDeflate = LibStub:GetLibrary("LibDeflate")
local LibSerialize = LibStub("LibSerialize")
E.chunks = {}
E.chunksToSend = {}

function E:SendEvent(channel, event, ...)
    self:Debug(event, "Processing payload for event", ...)
    local payload = self:PreparePayload(event, ...)
    if not payload then
        return
    end
    self:Debug(event, "Sending event", channel, payload)
    self:SendAddonMessage(payload, channel)
end

function E:SendEventTo(target, event, ...)
    self:Debug(event, "Processing payload for event", ...)
    local payload = self:PreparePayload(self.EVENT.WHISPER, event, target, ...)
    -- TODO FIND SOME WAY TO CHECK IF PLAYER IS ONLINE, CLIENT CACHING IS TOO SLOW
    --if not payload or (self.guildRoster[target] and not self.guildRoster[target][9] and E.stopIgnoringOffline) then
    --    self:Print("Event skipped. Player is offline or payload is empty.", online)
    --    return
    --end
    self:Debug(event, "Sending event to", target, payload)
    self:SendAddonMessage(payload, "GUILD")
end

function E:SendAddonMessage(payload, ...)
    local cps = #payload + self.cpsOverhead
    if cps > self:GetCPSLimit() then
        table.insert(self.cpsQueue, {payload, ...})
        return
    end
    self.cps = self.cps + cps
    C_ChatInfo.SendAddonMessage(self.NAME, payload, ...)
end

function E:PreparePayload(event, ...)
    local data = {...}
    if BohemianConfig.debug then
        for _, v in ipairs(data) do
            if v == nil or type(v) == "boolean" then
                self:Debug("Wrong data to send", event, v)
                return
            end
        end
    end
    local payload = table.concat(table.removeNil(data), self.EVENT_SEPARATOR)
    if #payload > 0 then
        payload = event..self.EVENT_SEPARATOR..payload
    else
        payload = event
    end
    return payload
end

function E:EncodePayload(data)
    local payload = table.concat(data, "\n")
    local serialized = LibSerialize:Serialize(payload)
    local compressed = LibDeflate:CompressDeflate(serialized)
    return LibDeflate:EncodeForWoWAddonChannel(compressed)
end

function E:DecodePayload(data)
    data = LibDeflate:DecodeForWoWAddonChannel(data)
    data = LibDeflate:DecompressDeflate(data)
    local _, deserialized = LibSerialize:Deserialize(data)
    return { strsplit("\n", deserialized) }
end

function E:PreparePayloadForSend(data)
    local id = E:uuid()
    data = self:EncodePayload(data)
    local chunks = self:splitStringByChunks(data, 267 - CHUNK_HEAD_SIZE - #id)
    local totalSize = #data + (#chunks * (self.cpsOverhead + CHUNK_HEAD_SIZE + #id))
    self:Debug("Sending data with size of", totalSize, "|| chunks:", #chunks)
    self:Debug("Sending will take", totalSize / BohemianConfig.cpsLimit, "seconds")
    self.chunksToSend[id] = chunks
    return id, chunks
end

function E:SendPayloadTo(target, type, data)
    local id, data = self:PreparePayloadForSend(data)
    self:SendEventTo(target, self.EVENT.PAYLOAD_START, type, #data, id)
end

function E:SendPayload(channel, type, data)
    local id, data = self:PreparePayloadForSend(data)
    self:SendEvent(channel, self.EVENT.PAYLOAD_START, type, #data, id)
end

function E:BroadcastPayload(payloadType, channel, data)
    local id, data = self:PreparePayloadForSend(data)
    self:SendEvent(channel, self.EVENT.BROADCAST_START, payloadType, #data, id)
    C_Timer.After(1, function()
        E:StartBroadcastPayload(id)
    end)
end


function E:OnWhisper(event, target, ...)
    if target ~= self:GetPlayerName(true) then
        return
    end
    if self.events[event] then
        self.events[event](self, ...)
    end
end

function E:ProcessEvent(message, channel, sender)
    local data = { strsplit(E.EVENT_SEPARATOR, message) }
    if not string.find(sender, "-") then
        sender = sender.."-"..GetNormalizedRealmName()
    end
    table.insert(data, sender)
    table.insert(data, channel)
    local event = table.remove(data,1)
    return event, data
end

function E:ProcessPayload(payload)

    E:Debug("Decoding chunks", id)
    local decoded = LibDeflate:DecodeForWoWAddonChannel(payload)
    if not decoded then
        E:Debug("Decoding failed", id)
        return
    end
    E:Debug("Decompressing chunks", id)
    local decompressed = LibDeflate:DecompressDeflate(decoded)
    if not decompressed then
        E:Debug("Decompression failed", id)
        return
    end
    E:Debug("Deserializing chunks", id)
    local success, data = LibSerialize:Deserialize(decompressed)
    if not success then
        E:Debug("Deserializing failed", id)
        return
    end
    return data
end

function E:GetPlayerChunks(name, type)
    local tmp = {}
    for _, chunk in pairs(E.chunks) do
        if chunk.name == name and chunk.type == type then
            tmp[#tmp + 1] = chunk
        end
    end
    return tmp
end
