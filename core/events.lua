---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by brode.
--- DateTime: 07.02.2022 17:39
---
---
local _, E = ...
local A = E.EVENTS
E.IsInitialized = false
E.QUEUE = {}

function A:ADDON_LOADED(name)
    if not self.IsInitialized then
        local requiredAddon = self.REQUIRED_ADDONS[name]
        if requiredAddon ~= nil then
            self:Debug('Required addon', name, 'loaded')
            self.REQUIRED_ADDONS[name] = true
        end
        local requiredAddonsLoaded = true
        for _, v in pairs (self.REQUIRED_ADDONS) do
            if not v then
                requiredAddonsLoaded = false
            end
        end
        if requiredAddonsLoaded then
            self.IsInitialized = true
            self:Debug("All dependencies loaded. Initializing...");
            local success = C_ChatInfo.RegisterAddonMessagePrefix(self.NAME)
            if success then
                self:Load()
                self:LoadModules()
            else
                self:Error("Failed to register messaging event!")
            end
        end
    end
    if tContains(self.AVAILABLE_MODULES, name) then
        local module = self.MODULES[name]
        self:Debug("Module", name, "loaded")
        if module then
            module.module.isLoaded = true
            if module.OnLoad then
                module.OnLoad(module.module)
            end
            E:OnEvent("MODULE_LOADED", module.module)
            E:ProcessModuleQueue(module.module)
            E:GuildStatus_UpdateHook()
        end
    end
end

function A:READY()
    E:InitialSync()
end

function A:ONLINE_CHECK(sender)
    if sender == E:GetPlayerName(true) then
        return
    end
    E:SendEventTo(sender, E.EVENT.ONLINE_CHECK_RESPONSE, E.onlineSince, BohemianConfig.lastTimeOnline or 0)
end

function A:ONLINE_CHECK_RESPONSE(time, lastTimeOnline, sender)
    if sender == E:GetPlayerName(true) then
        return
    end
    E.onlineChecks[sender] = { name = sender, onlineSince = tonumber(time), lastTimeOnline = tonumber(lastTimeOnline) or 0 }
end

function A:CHAT_MSG_ADDON(prefix, message, channel, sender)
    if prefix ~= E.NAME then return end
    local event, args
    if message:sub(1, 1) == E.COMPRESSED_SEPARATOR then
        event = E.EVENT.STREAM_DATA
        args = { message, channel, sender }
    else
        event, args = E:ProcessEvent(message, channel, sender)
    end
    E:OnEvent(event, unpack(args))
end


function A:GUILD_ROSTER_UPDATE(...)
    local members, onlineMembers, _ = GetNumGuildMembers();
    if members > 0 and E.firstLoad then
        E:CacheGuildRoster()
        E:GuildStatus_UpdateHook()
    end
    BohemianConfig.showOffline = GetGuildRosterShowOffline();
    E.lastOnlineMembers = onlineMembers
end

function A:GUILD_MEMBER_COUNT_CHANGED(offline, online)
    for player, _ in pairs(online) do
        E:SendEventTo(player.name, E.EVENT.ONLINE_CHECK)
        E:RequestVersionInfoFrom(player.name)
    end
    for player, _ in pairs(offline) do
        E.onlineChecks[player] = nil
    end
end

function A:PLAYER_ENTERING_WORLD(isLogin, isReload)
    if not isLogin and not isReload then
        return
    end
    GuildRoster()
    if IsInGuild() then
        E:LoadDataWhenReady()
    end
end

function A:PLAYER_LOGOUT()
    BohemianConfig.lastTimeOnline = GetServerTime()
end

function A:WHISPER(event, target, ...)
    if target ~= E:GetPlayerName(true) then
        return
    end
    E:OnEvent(event, ...)
end

function A:VERSION_INFO(version, sender)
    E.versions[sender] = version
    E:Debug(sender, "has version", version)
    E:VersionCheck()
end

function A:STREAM_DATA(message, channel, sender)
    local _, name = strsplit(E.EVENT_SEPARATOR, message:sub(2), 3)
    local id, order, msg
    if name == E:GetPlayerName(true) then
        id, name, order, msg = strsplit(E.EVENT_SEPARATOR, message:sub(2), 4)
    else
        id, order, msg = strsplit(E.EVENT_SEPARATOR, message:sub(2), 3)
    end
    local chunks = E.chunks[id]
    if not chunks then
        return
    end
    chunks.received = chunks.received + 1
    order = tonumber(order)
    if not order then
        return
    end
    chunks.data[order] = msg
    E:Debug("Saved chunk", order, id, chunks.type, chunks.received.."/"..chunks.size, sender)
    if chunks.size == chunks.received then
        E.chunks[id] = nil
        E:Debug("Processing chunks", id, chunks.type)
        if not chunks.data then
            return
        end
        local payload = table.concat(table.removeNil(chunks.data))
        local data = E:ProcessPayload(payload)
        E:Debug("Processed chunks", id, chunks.type)
        if not data then return end

        data = E:split(data, "\n")
        E:Debug("Executing chunks", id, chunks.type)
        for _, itemStr in ipairs(data) do
            local event, args = E:ProcessEvent(itemStr, channel, sender)
            E:OnEvent(event, unpack(args))
        end
        E:OnEvent("PAYLOAD_PROCESSED", chunks.type, id, sender)
    end
end


function A:PAYLOAD_START(payloadType, chunkAmount, remoteId, sender)
    local id = E:uuid()
    E:CreatePayload(payloadType, chunkAmount, id, sender)
    E:Debug("Prepared chunked payload with id", id, "|| size:", chunkAmount)
    E:SendEventTo(sender, E.EVENT.PAYLOAD_START_CONFIRM, remoteId, id)
end

function A:BROADCAST_START(payloadType, chunkAmount, remoteId, sender)
    E:CreatePayload(payloadType, chunkAmount, remoteId, sender)
    E:Debug("Prepared broadcast with id", remoteId, "|| size:", chunkAmount)
end

function A:PAYLOAD_START_CONFIRM(id, remoteId, sender)
    local chunks = E.chunksToSend[id]
    if not chunks then
        return
    end
    local sep = E.COMPRESSED_SEPARATOR..remoteId..E.EVENT_SEPARATOR..sender

    for i, chunk in ipairs(chunks) do
        local sep2 = E.EVENT_SEPARATOR..i
        E:SendAddonMessage(sep..sep2..E.EVENT_SEPARATOR..chunk, "GUILD")
    end
    E.chunksToSend[id] = nil
end

function A:GUILD_FRAME_UPDATE()
    E:UpdateColumnAfterUpdate()
    E:RenderLFGButtons()
    E:UpdateGMOTDState()
end


function A:GUILD_FRAME_AFTER_UPDATE()
    --print(GuildFrameColumnHeader2:GetWidth())

    E:SetGuildStatusColumnWidth()
    E:RenderGuildColumnHeadersAll()
    E:RenderGuildFrame()
    E:FixToggleButton()
    E:UpdateDetailFrame()
    --print(GuildFrame:GetWidth())
end

function A:VERSION_INFO_REQUEST(sender)
    if sender == E:GetPlayerName(true) then
        return
    end
    E:ShareVersionInfoTo(sender)
end


function A:SYNC_DONE()
    E:RequestVersionInfo()
    E:ShareVersionInfo()
end
